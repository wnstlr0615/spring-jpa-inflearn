## 6. JPA 프로그래밍 프로젝트 세팅
의존성 추가
properties 설정
datasource.url
datasource.username
datasource.password

spring.jpa.hibernate.ddl-auto=create

# update 사용 시 주의
기존 변수 삭제시 테이블에 칼럼 명이 남는다.
변수 명 변경시 기존 변수 칼럼은 유지되고 새로운 칼럼이 추가된다.
===========================================================
7.	JPA 프로그래밍: 엔티티 맵핑
@Entity
●	“엔티티”는 객체 세상에서 부르는 이름.
●	보통 클래스와 같은 이름을 사용하기 때문에 값을 변경하지 않음.
●	엔티티의 이름은 JQL에서 쓰임.

@Table
●	“릴레이션" 세상에서 부르는 이름.
●	@Entity의 이름이 기본값.
●	테이블의 이름은 SQL에서 쓰임.

@Id
●	엔티티의 주키를 맵핑할 때 사용.
●	자바의 모든 primitive 타입과 그 랩퍼 타입을 사용할 수 있음
○	Date랑 BigDecimal, BigInteger도 사용 가능.
●	복합키를 만드는 맵핑하는 방법도 있지만 그건 논외로..

@GeneratedValue
●	주키의 생성 방법을 맵핑하는 애노테이션
●	생성 전략과 생성기를 설정할 수 있다.
○	기본 전략은 AUTO: 사용하는 DB에 따라 적절한 전략 선택
○	TABLE, SEQUENCE, IDENTITY 중 하나.

@Column
●	unique
●	nullable
●	length
●	columnDefinition
●	...

@Temporal
●	현재 JPA 2.1까지는 Date와 Calendar만 지원.

@Transient
===========================================================
8.	JPA 프로그래밍: Value 타입 맵핑

@Embedded와 @Embeddable 사용
@AttributeOverrides 와 @AttributeOverride
같은 부류의 변수들을 새로운 클래스를 생성하여 표기하는 방법
중복 특성을 가지는 변수들을 중복 생성하는 방법
===========================================================
9.	JPA 프로그래밍: 1대다 맵핑
관계에 주인은 다쪽이 가진다.
일 대 다 단방향 매핑
다 대 일 단방향 매핑

일 대 다 양방향 매핑
양방향 매핑시 @OneToMany 에 관계에 주인 설정

양방향 관계시 관계를 형성하는 구문을 하나의 메소드로  묶어서 생성
 public void addStudy(Study study) {
        this.getStudies().add(study);
        study.setOwner(this);
    }
    public void removeStudy(Study study) {
        this.getStudies().remove(study);
        study.setOwner(null);
    }
===========================================================
10.	JPA 프로그래밍: Cascade
 @OneToMany(mappedBy = "post", cascade = CascadeType.ALL )
    private Set<Comment> comments=new HashSet<>();

    cascade를 사용할 경우 객체에 변화에 따라 자동으로 전파

===========================================================
11.	JPA 프로그래밍: Fetch

oneToMany에 경우 기본 적으로 fetch가 lazy로 적용 되어 있다.
ManyToOne은 Eager 이다.
===========================================================
12.	JPA 프로그래밍: Query
/* TypeSafe 하지 않음

    TypedQuery<Post> query = entityManager.createQuery("select p from Post as p", Post.class);
    List<Post> posts = query.getResultList();
    posts.forEach(System.out::println);
    */

//TypeSafe한 방법
    CriteriaBuilder builder = entityManager.getCriteriaBuilder();
    CriteriaQuery<Post> query = builder.createQuery(Post.class);
    Root<Post> root = query.from(Post.class);
    query.select(root);
    List<Post> posts = entityManager.createQuery(query).getResultList();
    posts.forEach(System.out::println);

    다음과 같이 쿼리를 사용할 수도 있다.

===========================================================
13.	스프링 데이터 JPA 소개 및 원리
JpaRepository를 상속 받아 스프링데이터 JPA 사용
상속 받아 사용하기 때문에 테스트 코드를 추가로 작성 해주지 않아도 된다.
===========================================================
2부: 스프링 데이터 JPA 활용
15.	스프링 데이터 JPA 활용 파트 소개
16.	스프링 데이터 Common: Repository


@DataJpaTest 와 h2 Database에 scope를 test로 설정할 경우
h2데이터 베이스를 사용하여 테스트 검사

Page<Post> postPage = postRepository.findAll(PageRequest.of(0, 10));
다음과 같이 page로 반환 하여 받을 수 있음

Page<Post> findByTitleContains(String title, Pageable pageable);
다음과 같이 커스텀 쿼리 사용 가능 하다.
===========================================================
17.	스프링 데이터 Common: Repository 인터페이스 정의하기

@RepositoryDefinition(domainClass = Comment.class, idClass=Long.class)어노테이션을 사용하여
커스텀 한 Repository 만들기

===========================================================
18.	스프링 데이터 Common: Null 처리하기

스프링 데이터는 단일 데이터의 경우 Optional로 반환 가능
Optional의 경우 테스트 코드 작성 시
assertThat(byId).isEmpty(); 비어 있는 지 검사 한다.  (Null로 검사 하지 않음);
스프링5 부터 @NonNull, @Nullable 사용 가능
===========================================================
19.	스프링 데이터 Common: 쿼리 만들기 개요
스프링 데이터 저장소의 메소드 이름으로 쿼리 만드는 방법
●	메소드 이름을 분석해서 쿼리 만들기 (CREATE)
●	미리 정의해 둔 쿼리 찾아 사용하기 (USE_DECLARED_QUERY)
●	미리 정의한 쿼리 찾아보고 없으면 만들기 (CREATE_IF_NOT_FOUND)
===========================================================




